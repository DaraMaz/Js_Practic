 /*   //Урок №9. Переменные и строгий режим
    3 способа назначить переменную:

        1) let number = 5; (значение из коробки, когда мы задаем переменную с помощью let, можно спокойно достать и поменять) (let-"ключевое слово"; number-"название переменной"; =-"знак присваивания"; 5-"значение переменной")

        2) const leftBorderWidth = 1; (значение const мы менять не можем, по возможности, используем везде, где только можно) (const-"ключевое слово"; leftBorderWidth-"название", причем написанное с помощью стиля CamlCase, где слова просто склеены и каждое новое слово кроме первого пишется с заглавной буквы)

        3)var name = 'Dasha'; (устаревший вариант, который мы не используем, нарушает логику, т.к может использоваться еще до того, как сама переменная была объявлена (называется такое поведение: всплытие переменных и может потом, на более масштабных примерах привести к очень большим проблемам)) (как и let можно спокойно перезаписывать)
    
        const obj ={
            a: 50
        }; (прямых констант в js не бывает)
        
        number = 10;
        console.log(number); //всё заработает

        leftBorderWidth = 10; //не заработает

        obj.a =10; //заработает

    {
        let  result = 50; //не будет работать, но если поставить const или var, то всё заработает (это какая-то особенность let)
    }

    "use strict"; //говорит программе, что мы работаем в "современном режиме", где "исправлены баги и не работают старые стандарты" 
    //пишем в начале документа или в начале функции

    a = 13; //в старом js мы могли задать переменную без её объявления, когда у нас включен use strict, консоль выдаст ошибку, a is not defind

//Урок №10. (Дополнительный) Правила и типы названия переменных

    const a = 5000;
    const b = 4000;

    console.log ("Ширина дома: "+ a + ". Длина дома: " + b);  (в таком случае, если между объявлением переменных будет находится большое кол-во кода, то когда мы посмотрим на команду console.log, то сможем не понять, что означают a и b, поэтому следует называть елементы "по логике") 

    const width = 5000;
    const length = 4000;

    console.log ("Ширина дома: "+ width + ". Длина дома: " + length); (но можно сделать ещё лучше)

    const houseBodyWidth = 5000;
    const houseBodyLength = 4000;

    console.log ("Ширина дома: "+ houseBodyWidth + ". Длина дома: " + houseBodyLength); (максимально понятный и легковоспринимаемый вариант)

    ['ksjdfjsalfjj','dljfsajdl', 'lldsjflkjsf'].map(a => )
    
    //Request
    data
    response
    (встречаются варианты, где "простые" названия могут использоваться в качестве "технической" составляющей)

    Как можно объявлять сразу несколько переменных?
        Вариант №1) На разных строчках (двумя командами):
            const houseBodyWidth = 5000;
            const houseBodyLength = 4000;
        Вариант №2) Через запятую:
            const houseBodyWidth = 5000, houseBodyLength = 4000;
        Вариант №3) (Видоизмененный вариант 2) через новую строку:
            const houseBodyWidth = 5000, 
                houseBodyLength = 4000;

    
    Стили 
        snake_case (про нижнее подчеркивание: иногда такое используестя в названиях папок, НО никак не переменных если мы говорим про js)

        UPPER_SNAKE_CASE (такие названия переменных встретить в js уже можно, обычно в таком стиле называют константы. Такие переменные можно только использовать, даже если они не const (внегласное правило программистов))

        (без названия) const _apiBase =  '(тут ссылка)' (тоже нельзя трогать)

        Kebabe-case (ипользуется толко при названии файлов)

        PascalCase (используется для названия классов в js)

//Урок №11. Классификация типов данных в js

    Существует 8 разных типов данных (в уроке есть ссылка на таблицу):
        Простые типы  (примитивы): 
            1) Числа: 1,2,3 и т.д
            2) Строки: 'sting', 'name'
            3) Логический тип: 
            boolean (булево значение)-true/false,
            null (когда чего-то не существует),
            undefined (когда что-то существует, но у этого чего-то нет значения),
            Symbol,
            Biglnt
        
        Объекты:
            Спец. объекты:
                4) Массивы arrays [],
                5) Функции functions,
                6) Объект Даты,
                7) Рекулярные выражения,
                8) Ошибки
            Обычные объекты

    (Разбираем подробнее каждый тип данных)

    //Числа
        let number = 45.574; (при указании десятых долей и меньше ставиться НЕ запятая, а ТОЧКА)

        console.log(4/0); (в консоли получим infinity, что значит бесконечность  (подобные математические и не только ошибки, напрямую не связанные с программированием js "прощает"))

        console.log(-4/0); (в консоли получим ответ -infinity)
        console.log('string' * 9); (выдает ответ NaN (Not a Number))

    //Строка (всегда пишется с кавычками)
        const persone = "Alex";

        //Какие кавычки в каких ситуациях лучше использовать (в нативном js нет разницы, кстати есть ещё один вид кавычек помимо двойных и одинарных, (где буква ё) `` (бэктики), у них есть очень приятная особенность)
            
    //Логические типы
        (булийново значение)
        const bool = true; (/false)

        //null
        console.log(somesing); (будет ошибка ссылочного типа)

        //undefind
        let und;
        console.log(und); (пустой холодильник)

    //Объекты
        const obj = {  //объект
            name: "Dasha", //свойства объекта
            age: 14,
            isMarried: false
        };

        console.log(obj.name); (в консоли получим результат Dasha)
        console.log(obj["name"]); (воторой вариант записи, при которой, по началу, вылезла ошибка, обязательно нужны кавычки)

    //Массивы
        let array = ['plum.png', 'orange.jpg', 6, [], {}]
        console.log(array[1]); (!ВАЖНО! Нумерация начинается не с единицы, а с нуля)
        (Массив является частным случаем объектов)

        const array = {
            0 = 'plum.png',
            1 = 'orange.jpg' и т.д
        }



//Урок 12. (Дополнительный) Разница между объектами и массивами и неочевидные синтаксические возможности

    Разница между объектами и массивами
        Синтаксическая (основная разница в скобках)

            const arr = [1, 2, 3]; //arr = array/массив
            //в массивах ключевая осебенность - ПОРЯДОК ЭЛЛЕМЕНТОВ

            console.log(arr[0]);

            const obj = {a: 1, 
                b: 3};
            //объекты же - структура хранения данных в "ПАРНОМ ФОРМАТЕ"

            const odj = {
                Anna: 5000, //примечание: в объектах ключи можно писать без кавычек
                'Alice': 6000
            };   //про "парность" элементов. Мы видим, что у нас есть имя человека и его заработная плата, т.е идет пара ключ-значение. Про подобной ситуации с массивом мы потеряли бы смысл, суть (легко можно запутаться)

             const array = {
            0 = 'plum.png',
            1 = 'orange.jpg' и т.д
            } //массив - это видоизменённый объект

            2 способа создавать свойства:
                1) const list = {
                    1: 'flksf',
                    2: 'jdslj',
                    a: 'ksdflk'
                };

                list.b = '1234'; //здесь мы добавили новое свойство объекту

                console.log(list['b']); //без кавычек выдадет ошибку, обязательно нужны кавычки (без них js думает, что мы вызываем переменную)

                const b = 'b'; (я немного прослушала про этот момент)

                //у объектов можно создавать еще "дополнительные" объекты/массивы, получается матрёшка

                cosnt abc = {
                    def: {
                        ghi: {
                            и т.д
                        }
                    }
                };

//Урок №13. Простое общение с пользователем

    alert('Hello'); (на сайте будет вылезать "окошко" с надпистю Hello, это окошко встроено в браузер и редактировать мы его не можем. Используется, когда мы хотим о чём-то предупредить пользователя)

    const result = confirm("Are you here?"); (вылезает окно, в котором мы можем выбрать варианты ответа (отмена или ок). В переменную result будет записываться результат, который мы выбрали)
    
        const experiment = confirm("Your name is Dasha?");

    if (experiment = true){
        document.write ("Hello, Dasha");
    }
    else {
        document.write ("Hello, user");
    }

    const answer = prompt("Вам есть 18?", ""); (вторые кавычки нужны, чтоб поставить какой-либо дефолтный ответ. В переменной answer всегда ответ от пользователя будет иметь тип данных строка)

    (оператор, чтоб посмотреть тип данных (typeof))
    console.log (typeof(answer));

    // ВСЯ информация, которая идёт от ПОЛЬЗОВАТЕЛЯ будет строкой

    const answers = [];

    answers[0] = prompt("Как ваше имя?", "");
    answers[1] = prompt("Сколько вам лет?", "");

// Урок №14. Интерполяция (ES6)

    const category = 'toys';

    conslole.log('https://someurl.com/' + category);  //запись в старом формате (используется "+", что неудобно в ситуации, когда адрес состоит из большоно количества элементов)  
    
    console.log (`https://someurl.com//${category}/5`); //используется тип кавычек "бэктики", благодаря чему запись адреса получается более приятной
    
    const userName = "Dasha";
    alert(`привет, ${userName}`);
    

// Проверка моего вопроса, а можно ли задать объект не с помощью const, а с помощью let? (просто в уроках при объявлении объектов, массивов и прочего использовались только const)
   const obj = {
    name: 'Dasha', 
    age: 14
   }

   console.log (obj.name); //в консоли всё нормально, пока мы используем const

   let obj1 = {
    name: 'Dasha', 
    age: 14
   }

   console.log (obj1.name); //тоже всё заработает

   //видимо, const так часто используется потому, что, как уже было сказано, если есть возможность использовать const, то лучше брать именно его
   
// Урок №15 Операторы в js

   //вообще, я встречала слово 'операторы' в книге Турбо Паскаль, но не особо поняла значение слова. (могу попытаться. Оператор - это некие команды по типу console.log, направленные на совершение определённых действий в коде)

   (нет, я не правильно поняла. Операторы, как пример - это сложение(+), вычитание(-), умножение(*) и т.д)

   //очередной пример КОНКАТЕНАЦИИ (Конкатена́ция (лат. concatenatio «присоединение цепями; сцепле́ние») — операция склеивания объектов линейной структуры, обычно строк. Например, конкатенация слов «микро» и «мир» даст слово «микромир».)
        console.log('arr' + ' = object'); //всё строкой
        console.log(4 + ' = object'); //в итоге всё равно получим большой строкой

    //как избежать конкатенации, если одна (или несколько) из складываемых елементов в виде строк имеет в себе только число, и мы хотим сложить число в виде типа данных число с числом, записанным в виде типа данных строка, то можно перед числом, записанным в виде строки, поставить +
        console.log(4 + +'8'); //первое число как тип данных число, а второе в виде строки, перед вторым стоит +, значит сложение этих двух чисел не подлежит конкотенации
        //в консоли получим 12

    //если же не писать тот самый +, то сумма будет подлежать конкотенации
         console.log(3 + "6"); //в консоли получим 36

    //естественно, избежать конкотенации, если один из элементов не просто записан с помощью типа данных строка, а само содержимое этой строки является не числом, а, например текстом, не получится. Программа выдаст ошибку NaN (not a number)

    //этот самый "дополнительный" плюс называется УНАРНЫМ (т. к. использует для своей работы только один элемент)

    //инкремент и декремент (Инкреме́нт, инкрементирование (от англ. increment «увеличение») — операция во многих языках программирования, увеличивающая значение переменной. Обратную операцию называют декремент (уменьшение).)
    Вопрос с собеседований: Чем отличается префексная форма от постфиксной
    (Префиксная запись выражения требует, чтобы все операторы предшествовали двум операндам, с которыми они работают. Постфиксная, в свою очередь, требует, чтобы операторы шли после соответствующих операндов.)
        let incr = 10,
            decr = 10;
    
        incr++; //это называется оператор инкремента, т.е УВЕЛИЧЕНИЕ на 1
        decr--; //оператор дектемента, УМЕНЬШЕНИЕ на 1
        //такая форма записи, после значения, называется ПОСТФИКСНОЙ

        console.log(incr); //получилось: 11 (10 + 1)
        console.log(decr); //получилось: 9 (10 - 1)

        ++incr;
        --decr;
        //от порядка в консоли ничего не поменялось
        //такая форма записи, перед значением, называется ПРЕФЕКСНОЙ

    //В чём же разница между префексной и постфиксной формой записи?
        let incr = 10,
            decr = 10;

        console.log(incr++); //получилось: 10
        console.log(decr--); //получилось: 10
        //если использовать инкремент или декремент в ПОСТФИКСНОЙ ФОРМЕ сразу, то программа возвращает старое значение, т. е 10

        //если записать в ПРЕФЕКСТНОЙ ФОРМЕ, то всё заработает

//Мой наглядный пример для разъяснения, что такое объекты

    У нас есть ручка, у коротой есть некоторые свойства
     const pen = { //это непосредственно наш объект - ручка
        colorBody: nocolor, //тут мы говорим, что корпус нашей ручки не имеет цвета (прозрачный)
        colorWrite: black, //наша ручка будет писать чёрными чернилами
        material: plastic, //ручка сделана из пластика
        consistency: gel. //ручка гелевая
    }

    //При разных объектах и целях создания этих объектов некоторые данные о них могут быть нам полезны, а другие наоборот, будут мешать. Так, например, если нам важен функционал ручки, то мы будем смотреть на такие данные как цвет чернил, вид пасты, удобство формы и т.д. Остальные же данные по типу цвета корпуса, наличия "украшений" и прочего нам будут не важны. И наоборот (на самом деле я сама не совсем поняла, зачем я написала эти рассуждения, хотя, возможно, из них можно сделать вывод, что, хоть мы и можем создать буквально неограниченное кол-во свойств объекту, важно учитывать, что действительно важными и используемыми будут далеко не все свойства)

//Урок №15 (продолжение)
    //Ещё один оператор - остаток от деления %
        console.log(5%2); //в консоли получим 1, т.е. мы разделили 5 на 2 возможное кол-во раз и, когда мы уже не можем разделить число на 2 программа пишет получившееся значение (это так, если вдруг забуду, что такое остаток от деления)

    //Оператор равенства. 
        //Если используется только один раз, то это называется ПРИСВАИВАНИЕМ
            const a = 5; //здесь мы присвоили переменной a значение 5
        
        //Если используестя два знака, то это "сравнение"
            console.log(2*4 == 8); //мы проверяем, действительно ли 2*4 = 8?
            //в консоли получим true 

            console.log(2*4 == '8'); //тоже всё заработает, не проверяется тип данных

        //Если используется три знака, то это строгое равенство, где должны совпадать ещё и типы данных
            console.log(2*4 === '8'); //в консоли получим false

    //Операторы 'и' и 'или'
        //оператор 'и' (&&) //два амперсанта
        //оператор 'или' (||)

        const isChecked = true,
            isClose = true;
        console.log(isChecked && isClose); //в консоли выдаст true (оба выражения верны)

        const isChecked = true,
            isClose = false;
        console.log(isChecked && isClose); //в консоли получим false

        //Т.е. оператор 'и' возвращает правду только в том случае, когда все "проверяемые" элементы тоже являются правдой

        //При использовании оператора 'или', когда оба элемента (на самом деле эти элементы называют аргументами) правда, нам, как ни странно, выдаст правду. Если же хотя бы один из множества элементов правда, даже если все остальные ложь, консоль выдаст правду
            const isChecked = true,
            isClose = false;
            console.log(isChecked || isClose); //выдаст true

    //Оператор отрицания (!) (используется для изменения "булийного" значения на противоположное)
        const isChecked = false,
        isClose = false;
        console.log(isChecked || isClose); //при таком условии все значения у нас false, следовательно, в консоли тоже будет false, однако, если мы поменяем одно из значений на обратное (из false на true), то, т.к. тут оператор или, мы получим ответ true
        console.log(isChecked || !isClose); //значение isClose мы поменяли с помощью оператора отрицания с false на true, в консоли получим true

        //ещё вариант комбинации этого оператора
            console.log(2 + 2 * 2 != 8); //изначально программа говорила бы ложь. Т. е. 6 равно 8 - неправда, но когда мы поставили оператор отрицания, то получилось неравенство, т.е. 6 НЕ равно 8, а это уже правда

    //Порядок выполнения операторов
        console.log(2 + 2 * 2 === 8); //при решении левой части мы получим ответ 6, что не совпадает с 8, получим false, тут всё работает как и в обычной математике, умножение имеет приоритет перед сложением

//Урок № 16 Учимся работать с системой контроля версий Git и с сервисом GitHub
    Что такое контроль версий?
        //Пример: я работаю над своим проектом и в определённый момент хочу написать в нём какие-нибудь дополнения, при этом, я осознаю, что, чтобы, если проект сломается, я смогла восстановить старую версию ещё без изменений, мне нужно сохранить эту версию. Некоторые начинают просто копировать свои проекты, но такой подход слишком не рационален. Для таких ситуаций есть программы, позволяющие сохранять "контрольные точки" - Системы Контроля Версий (СКВ). Самая популярная и удобная из них - Git, с которым мы, собственно, и будем работать.
    Плюсы использования Git:
        +операция сохранения контрольных точек происходит всего в несколько кликов
        +экономия памяти
        +с репозиториями ("складами" контрольных точек) может работать сразу несколько человек

    Как использовать?
        первым делом нам нужно открыть "командную строку" (это можно сделать через поиск в виндоус или через нужную папку (1. Открываем папку с проектом. 2.Shift+ПКМ 3.Пункт "Открыть окно команд" по оаавылод а.. я не поняла что в этом способе нужно делать)) или просто сделать это в Visual Studio Code

        Не знаю, сделала ли я правильно, но я просто выбрала свой проект в папках (пока что только этот js файл, не весь проект), нажала Shift+ПКМ, открыть с помощью git bush, сказала ему отслеживать (командой git init) и всё заработало (причём на папке (на всём проекте это тоже работает))

        git config (конфигурируем файлы, можем сделать это локально (настройки в отдельных проектах) или глобально (поставить на весь компьютер)) 

        git config --local user.name //дальше мы задаем название (насколько я поняла) для репозитория 
        //!ВАЖНО! Перед local, оказывается, нельзя ставить пробел, мне выдало ошибку

        git config --local user.email //указываем почту
        git config --local user.email daramazovec@gmail.com

        //Чтобы проверить, сохранились ли данные, можно открыть папку git внутри папки проекта, открыть внутреннюю папку config: 
        [user]
	        name = JS_Practic
	        email = daramazovec@gmail.com
        //я открывала через VSCode и всё работало

        //чтоб сделать настройки глобальными нужно просто local поменять на global

        //на данный момент над файлами не проводится никаких операций (имеют состояние 1)

        3 состояния работы git:
            1) Файлы просто существуют
            2) git следит за определёнными файлами (в таком случае файлы попадают в index)
            3) git создал контрольную точку

        //commit - контрольная точка

        //чтоб файлы перешли в состояние 2:
            git add -A //-A все файлы (all) не добавленные в индекс туда добавятся

            //причём если на отдельный файл папки с проектом уже назначен отдельный git, то работать ничего не будет (только в этом самом личном git)
            //т.е. если мы хотим сделать отдельные записи не на весь проект а на отдельный файл, то мы можем сделаль для него индивидуальный git, но, в таком случае, правила, работающие ко всему проекту не будут работать на этом файле

            //если мы в папку с проектом добавим новый файл, то он будет относиться к первому состоянию файлов, а те файлы, которые были до создания нового, так и остануться в своём прежнем состоянии

        3 состояние, commit:
            commit -a //(all) -m"first commit" //(описание коммита)
      */